#include "Display.h"
#include "WProgram.h"
#include <LiquidCrystal.h>
#include <avr/pgmspace.h>
#define TIMER_START 	unsigned long t = micros();
#define TIMER_STOP 		t = micros()-t;  Serial.print("Took: "); \
										 Serial.print(t, DEC); \
										 Serial.println(" micros.");

/////////////////////
//Utility Functions//
/////////////////////
//Must be called in arduino setup, not before!
template <short Lines, short Chars>
void Display<Lines, Chars>::begin() 
{
	if (!this->_begun)
	{		
		_lcd.begin(_chars, _lines); 
		this->_begun = true;
	}	
}

template <short Lines, short Chars>
LiquidCrystal& Display<Lines, Chars>::getLCDObject() { return _lcd; }

template <short Lines, short Chars>
short Display<Lines, Chars>::getBacklightPin() { return _blPin; }

template <short Lines, short Chars>
void Display<Lines, Chars>::setBacklightPin(short backlightPin) {
    _blPin = backlightPin;
    pinMode(_blPin, OUTPUT);
    digitalWrite(_blPin, LOW);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::backlightOn() {
    if (_blPin > 0)
        digitalWrite(_blPin, HIGH);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::backlightOff() {
	if (_blPin > 0)
		digitalWrite(_blPin, LOW);
}

template <short Lines, short Chars>
bool Display<Lines, Chars>::getBacklightState() { return digitalRead(_blPin); }

template <short Lines, short Chars>
void Display<Lines, Chars>::setBacklightState(bool state) 
{ if (_blPin>0) digitalWrite(_blPin, state); }

template <short Lines, short Chars>
int Display<Lines, Chars>::getRow(int lineNum) { return max(0, min(_lines-1, lineNum-1)); } 

template <short Lines, short Chars>
int Display<Lines,Chars>::getCol(int charNum) { return max(0, min(_chars-1, charNum-1)); } 

template <short Lines, short Chars>
String& Display<Lines, Chars>::getBuffer(int lineNum) 
{ return _workingBuffers[getRow(lineNum)]; }

template <short Lines, short Chars>
void Display<Lines, Chars>::commit(short lineNum, bool pad=false) {
	String &currStr = _liveBuffers[getRow(lineNum)];
	const String &newStr = getBuffer(lineNum);
	short row = getRow(lineNum);
	short len = newStr.length();
	
	for (int i=0; i<len && i<_chars; i++)
		if (currStr[i] != newStr[i]) {
			_lcd.setCursor(i, row);
			_lcd.print(newStr[i]);
		}
	if (pad) {
		_lcd.setCursor(len,row);
		for (int i=len; i<_chars; i++) 
			_lcd.print(' ');
	}
	
	currStr = newStr;
}

template <short Lines, short Chars>
String Display<Lines, Chars>::pstrToString(const prog_char* pstr) {
	int charNum = 0;
	char c;
	String str;

	while ( (c = (char)pgm_read_byte(pstr+charNum)) != '\0' && charNum < _chars) {
		str += c;
		charNum++;
	}
	return str;
}

template <short Lines, short Chars>
int Display<Lines, Chars>::countTrailingSpaces(const String &str) {
	Serial.println(String("in"));
	int spaces = 0;
	int loc = str.length()-1;
	while (str[loc] == ' ' && loc >= 0) { spaces++; loc--;}
	return spaces;
}

///////////////////
//Print Functions//
///////////////////
template <short Lines, short Chars>
void Display<Lines, Chars>::print(const String& str, short lineNum=1) {
	String &buf = getBuffer(lineNum);
	buf = str.substring(0,_chars);
	
	commit(lineNum, true);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::print(const char* str, short lineNum=1) 
{ print(String(str), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printPstr(const prog_char* pstr, short lineNum=1) 
{ print(pstrToString(pstr), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::print(const String& line1, const String& line2) { 
	this->print(line1, 1);
	this->print(line2, 2);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::print(const char* line1, const char* line2) {
	this->print(line1, 1);
	this->print(line2, 2);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::append(const String &str, short lineNum) {
	String& buf = getBuffer(lineNum);
	int origLength = buf.length();
	int charsLeft = _chars - origLength;
	if (charsLeft > 0) {
		buf+=str.substring(0,charsLeft);
		commit(lineNum);
	}
}

template <short Lines, short Chars>
void Display<Lines, Chars>::append(const char* str, short lineNum) 
{ append(String(str), lineNum); }
	

template <short Lines, short Chars>
void Display<Lines, Chars>::appendPstr(const prog_char* pstr, short lineNum) 
{ append(pstrToString(pstr), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printAt(const String &str, short lineNum, short charNum) {
	short row = getRow(lineNum);
	short printCol = getCol(charNum);

	if (row < _lines && printCol < _chars) {
		String &buf = getBuffer(lineNum);
		int len = str.length();
		while (buf.length() < min(_chars, printCol+str.length()))
			buf+=' ';
		for (int i=0; i<min(_chars-printCol,str.length()); i++)
			buf[i+printCol]=str[i];
		commit(lineNum);
	}
}

template <short Lines, short Chars>
void Display<Lines, Chars>::printAt(const char* str, short lineNum, short charNum)
{ printAt(String(str), lineNum, charNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printPstrAt(const prog_char* pstr, short lineNum, short charNum)
{ printAt(pstrToString(pstr), lineNum, charNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printAtEnd(const String& str, short lineNum) 
{ printAt(str, lineNum, _chars-str.length()+1); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printAtEnd(const char* str, short lineNum) 
{ printAtEnd(String(str), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printPstrAtEnd(const prog_char* pstr, short lineNum) 
{ printAtEnd(pstrToString(pstr), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::appendAtEnd(const String& str, short lineNum) {
	short charsLeft = _chars - getBuffer(lineNum).length();
	charsLeft += countTrailingSpaces(getBuffer(lineNum));
	if (charsLeft) {
		if (charsLeft < str.length())//any room?
			printAtEnd(str.substring(str.length()-charsLeft), lineNum);
		else
			printAtEnd(str, lineNum);
	}
}

template <short Lines, short Chars>
void Display<Lines, Chars>::appendAtEnd(const char* str, short lineNum) 
{ appendAtEnd(String(str), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::appendPstrAtEnd(const prog_char* pstr, short lineNum) 
{ appendAtEnd(pstrToString(pstr), lineNum); }


#ifndef Display_h
#define Display_h

#include "WProgram.h"
#include <LiquidCrystal.h>
#include <avr/pgmspace.h>

#define TIMER_START 	unsigned long t = micros();
#define TIMER_STOP 		t = micros()-t;  Serial.print("Took: "); \
										 Serial.print(t, DEC); \
										 Serial.println(" micros.");

void* operator new(size_t size) { return malloc(size); };
void* operator new[](size_t size)  { return malloc(size); };
void operator delete(void* ptr) { if (ptr) free(ptr); };

template <short Lines, short Chars> 
class Display {
  
	public:
	
	//ctors/dtors
    Display(short pins[6]) :
		_lcd(pins[0], pins[1], pins[2], pins[3], pins[4], pins[5]),
		_blPin(-1), _begun(false), _lines(Lines), _chars(Chars) { };
    
    Display(short pins[6], short backlightPin) :
		_lcd(pins[0], pins[1], pins[2], pins[3], pins[4], pins[5]),
		_blPin(backlightPin), _begun(false), _lines(Lines), _chars(Chars)
		{ setBacklightPin(_blPin); };
	
	virtual ~Display() {};
    
	//Utility Methods
	void begin();
    LiquidCrystal& getLCDObject();
	short getBacklightPin();
	void setBacklightPin(short backlightPin);
	void backlightOn();
	void backlightOff();
	void setBacklightState(bool state);
	bool getBacklightState();
	
	//Printing methods
	void print(const String& str, short lineNum);
	void print(const char* str, short lineNum);
	void printPstr(const prog_char* pstr, short lineNum);
    void print(const String& line1, const String& line2);
    void print(const char* line1, const char* line2);
	void printAt(const char* str, short lineNum, short colNum);
	void printAt(const String& str, short lineNum, short colNum);
	void printPstrAt(const prog_char* pstr, short lineNum, short charNum);
	void append(const char* str, short lineNum);
	void append(const String& str, short lineNum);
	void appendPstr(const prog_char* pstr, short lineNum);
	void printAtEnd(const char* str, short lineNum);
	void printAtEnd(const String& str, short lineNum);
	void printPstrAtEnd(const prog_char* pstr, short lineNum);
	void appendAtEnd(const char* str, short lineNum);
	void appendAtEnd(const String& str, short lineNum);
	void appendPstrAtEnd(const prog_char* pstr, short lineNum);
    
	protected:
    LiquidCrystal _lcd;
	String* _workingBuffers;
	String* _liveBuffers;
	short _blPin;
	short _lines, _chars;
    bool _begun;
	
	int getRow(int lineNum);
	int getCol(int charNum);
	String& getBuffer(int lineNum);
	void commit(short lineNum, bool pad);
	String pstrToString(const prog_char* pstr);
	int countTrailingSpaces(const String &str);
	
};

///////////////////////////////////////////////////////////
//Implementation
///////////////////////////////////////////////////////////

/////////////////////
//Utility Functions//
/////////////////////
//Must be called in arduino setup, not before!

void Display<Lines, Chars>::begin() 
{
	if (!this->_begun)
	{
		
		Serial.println(String("_workingBuffers: \"")+(long)_workingBuffers+"\"");
		_workingBuffers = new String[_lines];
		Serial.println(String("_liveBuffers: \"")+(long)_liveBuffers+"\"");
		Serial.println(String("_liveBuffers: \"")+(long)_liveBuffers+"\"");
		_liveBuffers = new String[_lines];
		Serial.println(String("_liveBuffers: \"")+(long)_liveBuffers+"\"");
		Serial.println(String("_liveBuffers[0]: \"")+_liveBuffers[0]+"\"");
		_liveBuffers[0] = "Zzzzzzzz.....";
		Serial.println(String("_liveBuffers[0]: \"")+_liveBuffers[0]+"\"");
		_lcd.begin(_chars, _lines); 
		_begun = true;
	}	
}

template <short Lines, short Chars>
LiquidCrystal& Display<Lines, Chars>::getLCDObject() { return _lcd; }

template <short Lines, short Chars>
short Display<Lines, Chars>::getBacklightPin() { return _blPin; }

template <short Lines, short Chars>
void Display<Lines, Chars>::setBacklightPin(short backlightPin) {
    _blPin = backlightPin;
    pinMode(_blPin, OUTPUT);
    digitalWrite(_blPin, LOW);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::backlightOn() {
    if (_blPin > 0)
        digitalWrite(_blPin, HIGH);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::backlightOff() {
	if (_blPin > 0)
		digitalWrite(_blPin, LOW);
}

template <short Lines, short Chars>
bool Display<Lines, Chars>::getBacklightState() { return digitalRead(_blPin); }

template <short Lines, short Chars>
void Display<Lines, Chars>::setBacklightState(bool state) 
{ if (_blPin>0) digitalWrite(_blPin, state); }

template <short Lines, short Chars>
int Display<Lines, Chars>::getRow(int lineNum) { return max(0, min(_lines-1, lineNum-1)); } 

template <short Lines, short Chars>
int Display<Lines,Chars>::getCol(int charNum) { return max(0, min(_chars-1, charNum-1)); } 

template <short Lines, short Chars>
String& Display<Lines, Chars>::getBuffer(int lineNum) 
{ return _workingBuffers[getRow(lineNum)]; }

template <short Lines, short Chars>
void Display<Lines, Chars>::commit(short lineNum, bool pad=false) {
	String &currStr = _liveBuffers[getRow(lineNum)];
	const String &newStr = getBuffer(lineNum);
	short row = getRow(lineNum);
	short len = newStr.length();
	
	for (int i=0; i<len && i<_chars; i++)
		if (currStr[i] != newStr[i]) {
			_lcd.setCursor(i, row);
			_lcd.print(newStr[i]);
		}
	if (pad) {
		_lcd.setCursor(len,row);
		for (int i=len; i<_chars; i++) 
			_lcd.print(' ');
	}
	
	currStr = newStr;
}

template <short Lines, short Chars>
String Display<Lines, Chars>::pstrToString(const prog_char* pstr) {
	int charNum = 0;
	char c;
	String str;

	while ( (c = (char)pgm_read_byte(pstr+charNum)) != '\0' && charNum < _chars) {
		str += c;
		charNum++;
	}
	return str;
}

template <short Lines, short Chars>
int Display<Lines, Chars>::countTrailingSpaces(const String &str) {
	Serial.println(String("in"));
	int spaces = 0;
	int loc = str.length()-1;
	while (str[loc] == ' ' && loc >= 0) { spaces++; loc--;}
	return spaces;
}

///////////////////
//Print Functions//
///////////////////
template <short Lines, short Chars>
void Display<Lines, Chars>::print(const String& str, short lineNum=1) {
	String &buf = getBuffer(lineNum);
	buf = str.substring(0,_chars);
	
	commit(lineNum, true);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::print(const char* str, short lineNum=1) 
{ print(String(str), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printPstr(const prog_char* pstr, short lineNum=1) 
{ print(pstrToString(pstr), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::print(const String& line1, const String& line2) { 
	this->print(line1, 1);
	this->print(line2, 2);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::print(const char* line1, const char* line2) {
	this->print(line1, 1);
	this->print(line2, 2);
}

template <short Lines, short Chars>
void Display<Lines, Chars>::append(const String &str, short lineNum) {
	String& buf = getBuffer(lineNum);
	int origLength = buf.length();
	int charsLeft = _chars - origLength;
	if (charsLeft > 0) {
		buf+=str.substring(0,charsLeft);
		commit(lineNum);
	}
}

template <short Lines, short Chars>
void Display<Lines, Chars>::append(const char* str, short lineNum) 
{ append(String(str), lineNum); }
	

template <short Lines, short Chars>
void Display<Lines, Chars>::appendPstr(const prog_char* pstr, short lineNum) 
{ append(pstrToString(pstr), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printAt(const String &str, short lineNum, short charNum) {
	short row = getRow(lineNum);
	short printCol = getCol(charNum);

	if (row < _lines && printCol < _chars) {
		String &buf = getBuffer(lineNum);
		int len = str.length();
		while (buf.length() < min(_chars, printCol+str.length()))
			buf+=' ';
		for (int i=0; i<min(_chars-printCol,str.length()); i++)
			buf[i+printCol]=str[i];
		commit(lineNum);
	}
}

template <short Lines, short Chars>
void Display<Lines, Chars>::printAt(const char* str, short lineNum, short charNum)
{ printAt(String(str), lineNum, charNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printPstrAt(const prog_char* pstr, short lineNum, short charNum)
{ printAt(pstrToString(pstr), lineNum, charNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printAtEnd(const String& str, short lineNum) 
{ printAt(str, lineNum, _chars-str.length()+1); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printAtEnd(const char* str, short lineNum) 
{ printAtEnd(String(str), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::printPstrAtEnd(const prog_char* pstr, short lineNum) 
{ printAtEnd(pstrToString(pstr), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::appendAtEnd(const String& str, short lineNum) {
	short charsLeft = _chars - getBuffer(lineNum).length();
	charsLeft += countTrailingSpaces(getBuffer(lineNum));
	if (charsLeft) {
		if (charsLeft < str.length())//any room?
			printAtEnd(str.substring(str.length()-charsLeft), lineNum);
		else
			printAtEnd(str, lineNum);
	}
}

template <short Lines, short Chars>
void Display<Lines, Chars>::appendAtEnd(const char* str, short lineNum) 
{ appendAtEnd(String(str), lineNum); }

template <short Lines, short Chars>
void Display<Lines, Chars>::appendPstrAtEnd(const prog_char* pstr, short lineNum) 
{ appendAtEnd(pstrToString(pstr), lineNum); }



#endif
